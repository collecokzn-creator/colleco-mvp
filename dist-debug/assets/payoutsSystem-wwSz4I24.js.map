{"version":3,"file":"payoutsSystem-wwSz4I24.js","sources":["../../src/utils/subscriptionManager.js","../../src/utils/commissionCalculator.js","../../src/utils/payoutsSystem.js"],"sourcesContent":["/**\r\n * Subscription Lifecycle Manager\r\n * Handles all subscription state transitions, billing cycles, and persistence\r\n * Core of the revenue generation system\r\n */\r\n\r\nimport { getPlan, SUBSCRIPTION_PLANS as _SUBSCRIPTION_PLANS } from './subscriptionPlans.js';\r\n\r\nconst STORAGE_KEY = 'colleco.subscriptions';\r\nconst INVOICES_KEY = 'colleco.invoices';\r\nconst _BILLING_CYCLES_KEY = 'colleco.billing_cycles';\r\n\r\n/**\r\n * Get or initialize partner subscription\r\n */\r\nexport function getPartnerSubscription(partnerId) {\r\n  const subscriptions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');\r\n  \r\n  if (!subscriptions[partnerId]) {\r\n    // Initialize with free tier\r\n    subscriptions[partnerId] = {\r\n      partnerId,\r\n      planId: 'free',\r\n      planName: 'Free',\r\n      status: 'active',\r\n      startDate: new Date().toISOString(),\r\n      renewalDate: addMonths(new Date(), 1).toISOString(),\r\n      cancelledAt: null,\r\n      pausedAt: null,\r\n      features: getPlan('free').features,\r\n      commission: getPlan('free').commission,\r\n      history: [],\r\n    };\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(subscriptions));\r\n  }\r\n  \r\n  return subscriptions[partnerId];\r\n}\r\n\r\n/**\r\n * Upgrade or downgrade subscription\r\n */\r\nexport function updateSubscription(partnerId, newPlanId, options = {}) {\r\n  const subscriptions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');\r\n  const currentSub = subscriptions[partnerId] || getPartnerSubscription(partnerId);\r\n  const newPlan = getPlan(newPlanId);\r\n  \r\n  if (!newPlan) throw new Error(`Invalid plan: ${newPlanId}`);\r\n  \r\n  const oldPlanId = currentSub.planId;\r\n  const now = new Date();\r\n  \r\n  // Create transition record\r\n  const transition = {\r\n    from: oldPlanId,\r\n    to: newPlanId,\r\n    timestamp: now.toISOString(),\r\n    reason: options.reason || 'manual_upgrade',\r\n    prorationCredits: calculateProration(currentSub, newPlan),\r\n  };\r\n  \r\n  // Update subscription\r\n  currentSub.planId = newPlanId;\r\n  currentSub.planName = newPlan.name;\r\n  currentSub.features = newPlan.features;\r\n  currentSub.commission = newPlan.commission;\r\n  currentSub.status = 'active';\r\n  currentSub.startDate = now.toISOString();\r\n  currentSub.renewalDate = addMonths(now, 1).toISOString();\r\n  currentSub.history = (currentSub.history || []).concat(transition);\r\n  \r\n  // If transitioning from free to paid, create first invoice\r\n  if (oldPlanId === 'free' && typeof newPlan.monthlyPrice === 'number') {\r\n    createInvoice(partnerId, newPlanId, newPlan.monthlyPrice, 'subscription_upgrade');\r\n  }\r\n  \r\n  subscriptions[partnerId] = currentSub;\r\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(subscriptions));\r\n  \r\n  return {\r\n    success: true,\r\n    subscription: currentSub,\r\n    transition,\r\n    nextBillingDate: currentSub.renewalDate,\r\n  };\r\n}\r\n\r\n/**\r\n * Pause subscription (keep access, skip billing)\r\n */\r\nexport function pauseSubscription(partnerId) {\r\n  const subscriptions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');\r\n  const sub = subscriptions[partnerId];\r\n  \r\n  if (!sub) throw new Error('Subscription not found');\r\n  \r\n  sub.status = 'paused';\r\n  sub.pausedAt = new Date().toISOString();\r\n  sub.history.push({\r\n    event: 'paused',\r\n    timestamp: new Date().toISOString(),\r\n  });\r\n  \r\n  subscriptions[partnerId] = sub;\r\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(subscriptions));\r\n  \r\n  return {\r\n    success: true,\r\n    message: 'Subscription paused. You can resume anytime.',\r\n    subscription: sub,\r\n  };\r\n}\r\n\r\n/**\r\n * Resume paused subscription\r\n */\r\nexport function resumeSubscription(partnerId) {\r\n  const subscriptions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');\r\n  const sub = subscriptions[partnerId];\r\n  \r\n  if (!sub) throw new Error('Subscription not found');\r\n  if (sub.status !== 'paused') throw new Error('Subscription is not paused');\r\n  \r\n  sub.status = 'active';\r\n  sub.pausedAt = null;\r\n  sub.renewalDate = addMonths(new Date(), 1).toISOString();\r\n  sub.history.push({\r\n    event: 'resumed',\r\n    timestamp: new Date().toISOString(),\r\n  });\r\n  \r\n  subscriptions[partnerId] = sub;\r\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(subscriptions));\r\n  \r\n  return {\r\n    success: true,\r\n    message: 'Subscription resumed.',\r\n    subscription: sub,\r\n  };\r\n}\r\n\r\n/**\r\n * Cancel subscription\r\n */\r\nexport function cancelSubscription(partnerId, reason = '') {\r\n  const subscriptions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');\r\n  const sub = subscriptions[partnerId];\r\n  \r\n  if (!sub) throw new Error('Subscription not found');\r\n  \r\n  sub.status = 'cancelled';\r\n  sub.cancelledAt = new Date().toISOString();\r\n  sub.cancelReason = reason;\r\n  \r\n  // Downgrade to free tier\r\n  const freePlan = getPlan('free');\r\n  sub.planId = 'free';\r\n  sub.planName = freePlan.name;\r\n  sub.features = freePlan.features;\r\n  sub.commission = freePlan.commission;\r\n  \r\n  sub.history.push({\r\n    event: 'cancelled',\r\n    timestamp: new Date().toISOString(),\r\n    reason,\r\n  });\r\n  \r\n  subscriptions[partnerId] = sub;\r\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(subscriptions));\r\n  \r\n  return {\r\n    success: true,\r\n    message: 'Subscription cancelled. You have been downgraded to Free tier.',\r\n    subscription: sub,\r\n  };\r\n}\r\n\r\n/**\r\n * Get commission rate for partner\r\n */\r\nexport function getCommissionRate(partnerId) {\r\n  const sub = getPartnerSubscription(partnerId);\r\n  return sub.commission.base;\r\n}\r\n\r\n/**\r\n * Apply commission bonus (for performance tiers)\r\n */\r\nexport function getEffectiveCommissionRate(partnerId, performanceMetrics = {}) {\r\n  const sub = getPartnerSubscription(partnerId);\r\n  let rate = sub.commission.base;\r\n  \r\n  // Apply bonus if metrics qualify\r\n  if (performanceMetrics.occupancyRate > 80) {\r\n    rate = Math.min(rate + sub.commission.bonusPercentage, sub.commission.maxCommission);\r\n  }\r\n  \r\n  return rate;\r\n}\r\n\r\n/**\r\n * Create invoice\r\n */\r\nexport function createInvoice(partnerId, planId, amount, type = 'monthly_subscription') {\r\n  const invoices = JSON.parse(localStorage.getItem(INVOICES_KEY) || '{}');\r\n  if (!invoices[partnerId]) invoices[partnerId] = [];\r\n  \r\n  const plan = getPlan(planId);\r\n  const invoice = {\r\n    id: `INV_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n    partnerId,\r\n    planId,\r\n    planName: plan.name,\r\n    amount,\r\n    type,\r\n    status: 'pending', // pending, paid, failed, refunded\r\n    issuedAt: new Date().toISOString(),\r\n    dueDate: addDays(new Date(), 14).toISOString(),\r\n    paidAt: null,\r\n    items: [\r\n      {\r\n        description: `${plan.name} Subscription`,\r\n        quantity: 1,\r\n        unitPrice: amount,\r\n        total: amount,\r\n      },\r\n    ],\r\n  };\r\n  \r\n  invoices[partnerId].push(invoice);\r\n  localStorage.setItem(INVOICES_KEY, JSON.stringify(invoices));\r\n  \r\n  return invoice;\r\n}\r\n\r\n/**\r\n * Mark invoice as paid\r\n */\r\nexport function markInvoicePaid(invoiceId, partnerId, paymentMethod = 'stripe') {\r\n  const invoices = JSON.parse(localStorage.getItem(INVOICES_KEY) || '{}');\r\n  const partnerInvoices = invoices[partnerId] || [];\r\n  const invoice = partnerInvoices.find(i => i.id === invoiceId);\r\n  \r\n  if (!invoice) throw new Error('Invoice not found');\r\n  \r\n  invoice.status = 'paid';\r\n  invoice.paidAt = new Date().toISOString();\r\n  invoice.paymentMethod = paymentMethod;\r\n  \r\n  invoices[partnerId] = partnerInvoices;\r\n  localStorage.setItem(INVOICES_KEY, JSON.stringify(invoices));\r\n  \r\n  return invoice;\r\n}\r\n\r\n/**\r\n * Get billing history\r\n */\r\nexport function getBillingHistory(partnerId, limit = 12) {\r\n  const invoices = JSON.parse(localStorage.getItem(INVOICES_KEY) || '{}');\r\n  const partnerInvoices = invoices[partnerId] || [];\r\n  \r\n  return partnerInvoices\r\n    .sort((a, b) => new Date(b.issuedAt) - new Date(a.issuedAt))\r\n    .slice(0, limit)\r\n    .map(inv => ({\r\n      ...inv,\r\n      daysOverdue: inv.status === 'pending' ? \r\n        Math.max(0, Math.floor((Date.now() - new Date(inv.dueDate)) / (1000 * 60 * 60 * 24))) : 0,\r\n    }));\r\n}\r\n\r\n/**\r\n * Check if subscription renewal is due\r\n */\r\nexport function isRenewalDue(partnerId) {\r\n  const sub = getPartnerSubscription(partnerId);\r\n  const renewalDate = new Date(sub.renewalDate);\r\n  const today = new Date();\r\n  \r\n  return today >= renewalDate && sub.status === 'active' && sub.planId !== 'free';\r\n}\r\n\r\n/**\r\n * Process subscription renewal\r\n */\r\nexport function processRenewal(partnerId) {\r\n  const sub = getPartnerSubscription(partnerId);\r\n  const plan = getPlan(sub.planId);\r\n  \r\n  if (plan.monthlyPrice === 0 || plan.monthlyPrice === 'custom') {\r\n    // Free/Enterprise don't auto-renew\r\n    return { success: false, reason: 'Plan does not require renewal' };\r\n  }\r\n  \r\n  // Create invoice for next month\r\n  const invoice = createInvoice(partnerId, sub.planId, plan.monthlyPrice, 'monthly_renewal');\r\n  \r\n  // Update renewal date\r\n  const subscriptions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');\r\n  sub.renewalDate = addMonths(new Date(), 1).toISOString();\r\n  subscriptions[partnerId] = sub;\r\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(subscriptions));\r\n  \r\n  return {\r\n    success: true,\r\n    invoice,\r\n    nextRenewalDate: sub.renewalDate,\r\n  };\r\n}\r\n\r\n/**\r\n * Get subscription statistics for partner\r\n */\r\nexport function getSubscriptionStats(partnerId) {\r\n  const sub = getPartnerSubscription(partnerId);\r\n  const invoices = getBillingHistory(partnerId, 12);\r\n  \r\n  const paidInvoices = invoices.filter(i => i.status === 'paid');\r\n  const totalPaid = paidInvoices.reduce((sum, i) => sum + i.amount, 0);\r\n  \r\n  const daysSinceStart = Math.floor((Date.now() - new Date(sub.startDate)) / (1000 * 60 * 60 * 24));\r\n  const monthsSinceStart = Math.floor(daysSinceStart / 30);\r\n  \r\n  return {\r\n    partnerId,\r\n    currentPlan: sub.planId,\r\n    planName: sub.planName,\r\n    status: sub.status,\r\n    daysSinceStart,\r\n    monthsSinceStart,\r\n    totalPaid,\r\n    totalInvoices: invoices.length,\r\n    paidInvoices: paidInvoices.length,\r\n    pendingInvoices: invoices.filter(i => i.status === 'pending').length,\r\n    failedInvoices: invoices.filter(i => i.status === 'failed').length,\r\n    monthlyRecurringRevenue: typeof getPlan(sub.planId).monthlyPrice === 'number' ? \r\n      getPlan(sub.planId).monthlyPrice : 0,\r\n    lifetimeValue: totalPaid,\r\n    averageMonthlySpend: totalPaid / Math.max(1, monthsSinceStart),\r\n  };\r\n}\r\n\r\n/**\r\n * Get all subscriptions (admin view)\r\n */\r\nexport function getAllSubscriptions() {\r\n  const subscriptions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');\r\n  return Object.values(subscriptions).map(sub => ({\r\n    ...sub,\r\n    stats: getSubscriptionStats(sub.partnerId),\r\n  }));\r\n}\r\n\r\n/**\r\n * Get subscription analytics\r\n */\r\nexport function getSubscriptionAnalytics() {\r\n  const allSubs = getAllSubscriptions();\r\n  \r\n  const byPlan = {};\r\n  let totalMRR = 0;\r\n  let totalLifetimeValue = 0;\r\n  \r\n  for (const sub of allSubs) {\r\n    if (!byPlan[sub.planId]) {\r\n      byPlan[sub.planId] = { count: 0, totalMRR: 0, totalLTV: 0 };\r\n    }\r\n    \r\n    byPlan[sub.planId].count++;\r\n    byPlan[sub.planId].totalMRR += sub.stats.monthlyRecurringRevenue;\r\n    byPlan[sub.planId].totalLTV += sub.stats.lifetimeValue;\r\n    \r\n    totalMRR += sub.stats.monthlyRecurringRevenue;\r\n    totalLifetimeValue += sub.stats.lifetimeValue;\r\n  }\r\n  \r\n  const statusCounts = {\r\n    active: allSubs.filter(s => s.status === 'active').length,\r\n    paused: allSubs.filter(s => s.status === 'paused').length,\r\n    cancelled: allSubs.filter(s => s.status === 'cancelled').length,\r\n  };\r\n  \r\n  const churnRate = statusCounts.cancelled / allSubs.length || 0;\r\n  \r\n  return {\r\n    totalPartners: allSubs.length,\r\n    activePartners: statusCounts.active,\r\n    pausedPartners: statusCounts.paused,\r\n    cancelledPartners: statusCounts.cancelled,\r\n    byPlan,\r\n    totalMRR,\r\n    totalLifetimeValue,\r\n    averageLTV: totalLifetimeValue / allSubs.length || 0,\r\n    churnRate,\r\n    adoptionByPlan: Object.entries(byPlan).map(([planId, data]) => ({\r\n      plan: getPlan(planId).name,\r\n      count: data.count,\r\n      percentage: (data.count / allSubs.length * 100).toFixed(1),\r\n      mrr: data.totalMRR,\r\n      ltv: data.totalLTV,\r\n    })),\r\n  };\r\n}\r\n\r\n// === Helper Functions ===\r\n\r\nfunction addMonths(date, months) {\r\n  const result = new Date(date);\r\n  result.setMonth(result.getMonth() + months);\r\n  return result;\r\n}\r\n\r\nfunction addDays(date, days) {\r\n  const result = new Date(date);\r\n  result.setDate(result.getDate() + days);\r\n  return result;\r\n}\r\n\r\nfunction calculateProration(currentSub, newPlan) {\r\n  // Prorated credits for mid-month changes\r\n  const currentPlan = getPlan(currentSub.planId);\r\n  if (currentPlan.monthlyPrice === 0 || typeof currentPlan.monthlyPrice !== 'number') {\r\n    return 0; // No proration for free tier\r\n  }\r\n  \r\n  const renewalDate = new Date(currentSub.renewalDate);\r\n  const today = new Date();\r\n  const daysRemaining = Math.ceil((renewalDate - today) / (1000 * 60 * 60 * 24));\r\n  const daysInMonth = 30;\r\n  \r\n  const dailyRate = currentPlan.monthlyPrice / daysInMonth;\r\n  const credit = dailyRate * daysRemaining;\r\n  \r\n  // Apply as credit toward new plan\r\n  const newCost = newPlan.monthlyPrice - credit;\r\n  \r\n  return {\r\n    oldPlanDailyRate: dailyRate,\r\n    daysRemaining,\r\n    creditAmount: credit,\r\n    newPlanCost: newPlan.monthlyPrice,\r\n    adjustedCost: Math.max(0, newCost),\r\n  };\r\n}\r\n","/**\r\n * Commission Calculation System\r\n * Calculates real-time earnings based on subscription tier\r\n * Integrates with booking flows to apply correct commission rate\r\n * Core revenue tracking for partners\r\n */\r\n\r\nimport { getCommissionRate, getEffectiveCommissionRate, getPartnerSubscription } from './subscriptionManager.js';\r\nimport { getPlan } from './subscriptionPlans.js';\r\n\r\nconst EARNINGS_KEY = 'colleco.partner_earnings';\r\nconst TRANSACTIONS_KEY = 'colleco.partner_transactions';\r\n\r\n/**\r\n * Calculate commission for a booking\r\n */\r\nexport function calculateCommission(partnerId, bookingAmount, bookingType = 'accommodation', performanceMetrics = {}) {\r\n  const baseRate = getCommissionRate(partnerId);\r\n  const effectiveRate = getEffectiveCommissionRate(partnerId, performanceMetrics);\r\n  \r\n  const commission = bookingAmount * effectiveRate;\r\n  \r\n  return {\r\n    bookingAmount,\r\n    bookingType,\r\n    baseRate,\r\n    performanceBonus: effectiveRate - baseRate,\r\n    effectiveRate,\r\n    commission: Math.round(commission * 100) / 100,\r\n    earnedAt: new Date().toISOString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Record booking transaction and apply commission\r\n */\r\nexport function recordBookingTransaction(partnerId, booking) {\r\n  const { bookingId, amount, type = 'accommodation', status = 'confirmed', performanceMetrics = {} } = booking;\r\n  \r\n  if (status !== 'confirmed') {\r\n    return { success: false, reason: 'Only confirmed bookings generate commission' };\r\n  }\r\n  \r\n  const commission = calculateCommission(partnerId, amount, type, performanceMetrics);\r\n  \r\n  // Record transaction\r\n  const transactions = JSON.parse(localStorage.getItem(TRANSACTIONS_KEY) || '{}');\r\n  if (!transactions[partnerId]) transactions[partnerId] = [];\r\n  \r\n  const transaction = {\r\n    id: `TXN_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n    partnerId,\r\n    bookingId,\r\n    bookingType: type,\r\n    bookingAmount: amount,\r\n    ...commission,\r\n    status: 'earned', // earned, paid, pending_payout\r\n    recordedAt: new Date().toISOString(),\r\n    paidOutAt: null,\r\n  };\r\n  \r\n  transactions[partnerId].push(transaction);\r\n  localStorage.setItem(TRANSACTIONS_KEY, JSON.stringify(transactions));\r\n  \r\n  // Update earnings summary\r\n  updateEarningsSummary(partnerId, transaction.commission);\r\n  \r\n  return {\r\n    success: true,\r\n    transaction,\r\n    message: `Commission recorded: R${transaction.commission.toLocaleString()} earned`,\r\n  };\r\n}\r\n\r\n/**\r\n * Update earnings summary for partner\r\n */\r\nfunction updateEarningsSummary(partnerId, commissionAmount) {\r\n  const earnings = JSON.parse(localStorage.getItem(EARNINGS_KEY) || '{}');\r\n  \r\n  if (!earnings[partnerId]) {\r\n    earnings[partnerId] = {\r\n      partnerId,\r\n      totalEarned: 0,\r\n      thisMonthEarned: 0,\r\n      thisMonthTransactions: 0,\r\n      lastUpdated: new Date().toISOString(),\r\n    };\r\n  }\r\n  \r\n  const now = new Date();\r\n  const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;\r\n  const monthKey = `earnings_${currentMonth}`;\r\n  \r\n  earnings[partnerId].totalEarned += commissionAmount;\r\n  earnings[partnerId].thisMonthEarned += commissionAmount;\r\n  earnings[partnerId].thisMonthTransactions++;\r\n  earnings[partnerId].lastUpdated = new Date().toISOString();\r\n  \r\n  // Track monthly history\r\n  if (!earnings[partnerId][monthKey]) {\r\n    earnings[partnerId][monthKey] = {\r\n      month: currentMonth,\r\n      earned: 0,\r\n      transactions: 0,\r\n    };\r\n  }\r\n  earnings[partnerId][monthKey].earned += commissionAmount;\r\n  earnings[partnerId][partnerId][monthKey].transactions++;\r\n  \r\n  localStorage.setItem(EARNINGS_KEY, JSON.stringify(earnings));\r\n}\r\n\r\n/**\r\n * Get partner earnings summary\r\n */\r\nexport function getEarningsSummary(partnerId) {\r\n  const earnings = JSON.parse(localStorage.getItem(EARNINGS_KEY) || '{}');\r\n  const sub = getPartnerSubscription(partnerId);\r\n  const plan = getPlan(sub.planId);\r\n  \r\n  const summary = earnings[partnerId] || {\r\n    partnerId,\r\n    totalEarned: 0,\r\n    thisMonthEarned: 0,\r\n    thisMonthTransactions: 0,\r\n  };\r\n  \r\n  // Calculate subscription costs\r\n  const subscriptionCost = typeof plan.monthlyPrice === 'number' ? plan.monthlyPrice : 0;\r\n  const netEarnings = summary.thisMonthEarned - subscriptionCost;\r\n  \r\n  return {\r\n    ...summary,\r\n    subscriptionCost,\r\n    netEarnings: Math.max(0, netEarnings),\r\n    commissionRate: `${(plan.commission.base * 100).toFixed(1)}%`,\r\n    tier: plan.name,\r\n  };\r\n}\r\n\r\n/**\r\n * Get detailed transactions for partner\r\n */\r\nexport function getPartnerTransactions(partnerId, limit = 50) {\r\n  const transactions = JSON.parse(localStorage.getItem(TRANSACTIONS_KEY) || '{}');\r\n  const partnerTransactions = transactions[partnerId] || [];\r\n  \r\n  return partnerTransactions\r\n    .sort((a, b) => new Date(b.recordedAt) - new Date(a.recordedAt))\r\n    .slice(0, limit)\r\n    .map(txn => ({\r\n      ...txn,\r\n      date: new Date(txn.recordedAt).toLocaleDateString(),\r\n      displayCommission: `R${txn.commission.toLocaleString()}`,\r\n      rateDisplay: `${(txn.effectiveRate * 100).toFixed(1)}%`,\r\n    }));\r\n}\r\n\r\n/**\r\n * Calculate monthly earnings report\r\n */\r\nexport function getMonthlyEarningsReport(partnerId, monthOffset = 0) {\r\n  const transactions = JSON.parse(localStorage.getItem(TRANSACTIONS_KEY) || '{}');\r\n  const partnerTransactions = transactions[partnerId] || [];\r\n  \r\n  const now = new Date();\r\n  const targetMonth = new Date(now.getFullYear(), now.getMonth() - monthOffset, 1);\r\n  const monthStart = targetMonth.toISOString().split('T')[0].substring(0, 7);\r\n  \r\n  const monthTransactions = partnerTransactions.filter(txn => {\r\n    const txnMonth = txn.recordedAt.substring(0, 7);\r\n    return txnMonth === monthStart;\r\n  });\r\n  \r\n  const totalBookingAmount = monthTransactions.reduce((sum, t) => sum + t.bookingAmount, 0);\r\n  const totalCommission = monthTransactions.reduce((sum, t) => sum + t.commission, 0);\r\n  \r\n  // Group by booking type\r\n  const byType = {};\r\n  for (const txn of monthTransactions) {\r\n    if (!byType[txn.bookingType]) {\r\n      byType[txn.bookingType] = { count: 0, amount: 0, commission: 0 };\r\n    }\r\n    byType[txn.bookingType].count++;\r\n    byType[txn.bookingType].amount += txn.bookingAmount;\r\n    byType[txn.bookingType].commission += txn.commission;\r\n  }\r\n  \r\n  // Calculate subscription cost for month\r\n  const sub = getPartnerSubscription(partnerId);\r\n  const plan = getPlan(sub.planId);\r\n  const subscriptionCost = typeof plan.monthlyPrice === 'number' ? plan.monthlyPrice : 0;\r\n  \r\n  return {\r\n    month: monthStart,\r\n    year: targetMonth.getFullYear(),\r\n    monthName: targetMonth.toLocaleString('default', { month: 'long', year: 'numeric' }),\r\n    transactions: monthTransactions.length,\r\n    totalBookingAmount: Math.round(totalBookingAmount * 100) / 100,\r\n    totalCommission: Math.round(totalCommission * 100) / 100,\r\n    byType: Object.entries(byType).map(([type, data]) => ({\r\n      type,\r\n      ...data,\r\n      average: Math.round(data.amount / data.count * 100) / 100,\r\n    })),\r\n    subscriptionCost,\r\n    netEarnings: Math.round((totalCommission - subscriptionCost) * 100) / 100,\r\n    averageCommissionRate: monthTransactions.length > 0 ?\r\n      (monthTransactions.reduce((sum, t) => sum + t.effectiveRate, 0) / monthTransactions.length * 100).toFixed(1) :\r\n      '0',\r\n  };\r\n}\r\n\r\n/**\r\n * Get year-to-date earnings\r\n */\r\nexport function getYearToDateEarnings(partnerId) {\r\n  const transactions = JSON.parse(localStorage.getItem(TRANSACTIONS_KEY) || '{}');\r\n  const partnerTransactions = transactions[partnerId] || [];\r\n  \r\n  const currentYear = new Date().getFullYear().toString();\r\n  const yearTransactions = partnerTransactions.filter(t => t.recordedAt.startsWith(currentYear));\r\n  \r\n  const totalCommission = yearTransactions.reduce((sum, t) => sum + t.commission, 0);\r\n  const totalBookingAmount = yearTransactions.reduce((sum, t) => sum + t.bookingAmount, 0);\r\n  \r\n  // Calculate subscription costs paid YTD\r\n  const sub = getPartnerSubscription(partnerId);\r\n  const plan = getPlan(sub.planId);\r\n  const monthlySubCost = typeof plan.monthlyPrice === 'number' ? plan.monthlyPrice : 0;\r\n  const monthsActive = Math.ceil((Date.now() - new Date(sub.startDate)) / (1000 * 60 * 60 * 24 * 30));\r\n  const totalSubscriptionCost = monthlySubCost * monthsActive;\r\n  \r\n  return {\r\n    year: currentYear,\r\n    transactions: yearTransactions.length,\r\n    totalBookingAmount: Math.round(totalBookingAmount * 100) / 100,\r\n    totalCommission: Math.round(totalCommission * 100) / 100,\r\n    totalSubscriptionCost: Math.round(totalSubscriptionCost * 100) / 100,\r\n    netEarnings: Math.round((totalCommission - totalSubscriptionCost) * 100) / 100,\r\n    averageMonthlyEarnings: Math.round((totalCommission / Math.max(1, monthsActive)) * 100) / 100,\r\n    averageBookingValue: yearTransactions.length > 0 ?\r\n      Math.round((totalBookingAmount / yearTransactions.length) * 100) / 100 : 0,\r\n    averageCommissionRate: yearTransactions.length > 0 ?\r\n      (yearTransactions.reduce((sum, t) => sum + t.effectiveRate, 0) / yearTransactions.length * 100).toFixed(1) :\r\n      '0',\r\n  };\r\n}\r\n\r\n/**\r\n * Get upcoming payout amount\r\n */\r\nexport function getUpcomingPayoutAmount(partnerId) {\r\n  const transactions = JSON.parse(localStorage.getItem(TRANSACTIONS_KEY) || '{}');\r\n  const partnerTransactions = transactions[partnerId] || [];\r\n  \r\n  // Unpaid transactions\r\n  const unpaidTransactions = partnerTransactions.filter(t => t.status === 'earned');\r\n  const totalEarned = unpaidTransactions.reduce((sum, t) => sum + t.commission, 0);\r\n  \r\n  // Subtract pending subscription charges\r\n  const sub = getPartnerSubscription(partnerId);\r\n  const plan = getPlan(sub.planId);\r\n  const pendingSubscriptionCharge = typeof plan.monthlyPrice === 'number' ? plan.monthlyPrice : 0;\r\n  \r\n  const payoutAmount = Math.max(0, totalEarned - pendingSubscriptionCharge);\r\n  \r\n  return {\r\n    totalEarned: Math.round(totalEarned * 100) / 100,\r\n    pendingCharges: pendingSubscriptionCharge,\r\n    payoutAmount: Math.round(payoutAmount * 100) / 100,\r\n    transactions: unpaidTransactions.length,\r\n    minimumPayoutThreshold: 100, // Minimum R100 payout\r\n    isReadyForPayout: payoutAmount >= 100,\r\n  };\r\n}\r\n\r\n/**\r\n * Mark transactions as paid (after payout)\r\n */\r\nexport function markTransactionsAsPaid(partnerId, transactionIds, payoutId) {\r\n  const transactions = JSON.parse(localStorage.getItem(TRANSACTIONS_KEY) || '{}');\r\n  const partnerTransactions = transactions[partnerId] || [];\r\n  \r\n  for (const txn of partnerTransactions) {\r\n    if (transactionIds.includes(txn.id)) {\r\n      txn.status = 'paid';\r\n      txn.paidOutAt = new Date().toISOString();\r\n      txn.payoutId = payoutId;\r\n    }\r\n  }\r\n  \r\n  transactions[partnerId] = partnerTransactions;\r\n  localStorage.setItem(TRANSACTIONS_KEY, JSON.stringify(transactions));\r\n  \r\n  return {\r\n    success: true,\r\n    transactionsPaid: transactionIds.length,\r\n    totalAmount: partnerTransactions\r\n      .filter(t => transactionIds.includes(t.id))\r\n      .reduce((sum, t) => sum + t.commission, 0),\r\n  };\r\n}\r\n\r\n/**\r\n * Get commission analytics\r\n */\r\nexport function getCommissionAnalytics() {\r\n  const transactions = JSON.parse(localStorage.getItem(TRANSACTIONS_KEY) || '{}');\r\n  \r\n  let totalCommission = 0;\r\n  let totalBookings = 0;\r\n  let totalBookingAmount = 0;\r\n  const topPartners = [];\r\n  \r\n  for (const [partnerId, txns] of Object.entries(transactions)) {\r\n    const partnerTotal = txns.reduce((sum, t) => sum + t.commission, 0);\r\n    const partnerBookingAmount = txns.reduce((sum, t) => sum + t.bookingAmount, 0);\r\n    \r\n    totalCommission += partnerTotal;\r\n    totalBookings += txns.length;\r\n    totalBookingAmount += partnerBookingAmount;\r\n    \r\n    topPartners.push({\r\n      partnerId,\r\n      transactions: txns.length,\r\n      totalCommission: Math.round(partnerTotal * 100) / 100,\r\n      totalBookingAmount: Math.round(partnerBookingAmount * 100) / 100,\r\n      averageCommissionPerBooking: Math.round((partnerTotal / txns.length) * 100) / 100,\r\n    });\r\n  }\r\n  \r\n  topPartners.sort((a, b) => b.totalCommission - a.totalCommission);\r\n  \r\n  return {\r\n    totalCommission: Math.round(totalCommission * 100) / 100,\r\n    totalBookings,\r\n    totalBookingAmount: Math.round(totalBookingAmount * 100) / 100,\r\n    averageCommissionPerBooking: totalBookings > 0 ?\r\n      Math.round((totalCommission / totalBookings) * 100) / 100 : 0,\r\n    activePartners: Object.keys(transactions).length,\r\n    topPartners: topPartners.slice(0, 10),\r\n  };\r\n}\r\n","/**\r\n * Payouts System\r\n * Manages partner payouts and payment distribution\r\n * Calculates net earnings after subscription costs\r\n */\r\n\r\nimport { getUpcomingPayoutAmount, markTransactionsAsPaid } from './commissionCalculator.js';\r\nimport { getPartnerSubscription as _getPartnerSubscription } from './subscriptionManager.js';\r\n\r\nconst PAYOUTS_KEY = 'colleco.payouts';\r\nconst PAYOUT_METHODS_KEY = 'colleco.payout_methods';\r\n\r\n/**\r\n * Add payout method for partner\r\n */\r\nexport function addPayoutMethod(partnerId, method) {\r\n  const { type, bankAccount, accountHolder, bankName } = method;\r\n  \r\n  if (type === 'bank_transfer') {\r\n    if (!bankAccount || !accountHolder || !bankName) {\r\n      throw new Error('Bank transfer requires account details');\r\n    }\r\n  }\r\n  \r\n  const methods = JSON.parse(localStorage.getItem(PAYOUT_METHODS_KEY) || '{}');\r\n  if (!methods[partnerId]) methods[partnerId] = [];\r\n  \r\n  const payoutMethod = {\r\n    id: `METHOD_${Date.now()}`,\r\n    ...method,\r\n    verified: false,\r\n    addedAt: new Date().toISOString(),\r\n    // In production, would require verification\r\n    verifiedAt: type === 'bank_transfer' ? null : new Date().toISOString(),\r\n  };\r\n  \r\n  methods[partnerId].push(payoutMethod);\r\n  localStorage.setItem(PAYOUT_METHODS_KEY, JSON.stringify(methods));\r\n  \r\n  return payoutMethod;\r\n}\r\n\r\n/**\r\n * Get payout methods for partner\r\n */\r\nexport function getPayoutMethods(partnerId) {\r\n  const methods = JSON.parse(localStorage.getItem(PAYOUT_METHODS_KEY) || '{}');\r\n  return methods[partnerId] || [];\r\n}\r\n\r\n/**\r\n * Set default payout method\r\n */\r\nexport function setDefaultPayoutMethod(partnerId, methodId) {\r\n  const methods = JSON.parse(localStorage.getItem(PAYOUT_METHODS_KEY) || '{}');\r\n  const partnerMethods = methods[partnerId] || [];\r\n  \r\n  for (const method of partnerMethods) {\r\n    method.isDefault = method.id === methodId;\r\n  }\r\n  \r\n  methods[partnerId] = partnerMethods;\r\n  localStorage.setItem(PAYOUT_METHODS_KEY, JSON.stringify(methods));\r\n  \r\n  return partnerMethods.find(m => m.isDefault);\r\n}\r\n\r\n/**\r\n * Get default payout method\r\n */\r\nexport function getDefaultPayoutMethod(partnerId) {\r\n  const methods = getPayoutMethods(partnerId);\r\n  return methods.find(m => m.isDefault) || methods[0] || null;\r\n}\r\n\r\n/**\r\n * Initiate payout for partner\r\n */\r\nexport function initiatePayout(partnerId, options = {}) {\r\n  const payoutData = getUpcomingPayoutAmount(partnerId);\r\n  \r\n  if (payoutData.payoutAmount < payoutData.minimumPayoutThreshold) {\r\n    return {\r\n      success: false,\r\n      reason: `Minimum payout threshold is R${payoutData.minimumPayoutThreshold}. Current amount: R${payoutData.payoutAmount}`,\r\n      current: payoutData.payoutAmount,\r\n      threshold: payoutData.minimumPayoutThreshold,\r\n    };\r\n  }\r\n  \r\n  const payoutMethod = options.methodId ? \r\n    getPayoutMethods(partnerId).find(m => m.id === options.methodId) :\r\n    getDefaultPayoutMethod(partnerId);\r\n  \r\n  if (!payoutMethod) {\r\n    return {\r\n      success: false,\r\n      reason: 'No payout method configured. Please add a bank account or payment method.',\r\n    };\r\n  }\r\n  \r\n  // Create payout record\r\n  const payouts = JSON.parse(localStorage.getItem(PAYOUTS_KEY) || '{}');\r\n  if (!payouts[partnerId]) payouts[partnerId] = [];\r\n  \r\n  const transactions = JSON.parse(localStorage.getItem('colleco.partner_transactions') || '{}');\r\n  const unpaidTransactionIds = (transactions[partnerId] || [])\r\n    .filter(t => t.status === 'earned')\r\n    .map(t => t.id);\r\n  \r\n  const payout = {\r\n    id: `PAYOUT_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n    partnerId,\r\n    amount: payoutData.payoutAmount,\r\n    grossAmount: payoutData.totalEarned,\r\n    subscriptionDeduction: payoutData.pendingCharges,\r\n    transactionCount: unpaidTransactionIds.length,\r\n    transactionIds: unpaidTransactionIds,\r\n    payoutMethod,\r\n    status: 'pending', // pending, processing, completed, failed\r\n    requestedAt: new Date().toISOString(),\r\n    processedAt: null,\r\n    completedAt: null,\r\n    reference: null,\r\n  };\r\n  \r\n  payouts[partnerId].push(payout);\r\n  localStorage.setItem(PAYOUTS_KEY, JSON.stringify(payouts));\r\n  \r\n  return {\r\n    success: true,\r\n    payout,\r\n    estimatedDelivery: addBusinessDays(new Date(), 2).toISOString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Get payout history\r\n */\r\nexport function getPayoutHistory(partnerId, limit = 12) {\r\n  const payouts = JSON.parse(localStorage.getItem(PAYOUTS_KEY) || '{}');\r\n  const partnerPayouts = payouts[partnerId] || [];\r\n  \r\n  return partnerPayouts\r\n    .sort((a, b) => new Date(b.requestedAt) - new Date(a.requestedAt))\r\n    .slice(0, limit)\r\n    .map(p => ({\r\n      ...p,\r\n      statusDisplay: getPayoutStatusDisplay(p.status),\r\n      estimatedDelivery: p.status === 'completed' ?\r\n        p.completedAt :\r\n        addBusinessDays(new Date(p.requestedAt), 2).toISOString(),\r\n    }));\r\n}\r\n\r\n/**\r\n * Get payout by ID\r\n */\r\nexport function getPayout(payoutId, partnerId) {\r\n  const payouts = JSON.parse(localStorage.getItem(PAYOUTS_KEY) || '{}');\r\n  const partnerPayouts = payouts[partnerId] || [];\r\n  \r\n  return partnerPayouts.find(p => p.id === payoutId) || null;\r\n}\r\n\r\n/**\r\n * Process payout (mark as completed)\r\n */\r\nexport function completePayout(payoutId, partnerId, reference = '') {\r\n  const payouts = JSON.parse(localStorage.getItem(PAYOUTS_KEY) || '{}');\r\n  const partnerPayouts = payouts[partnerId] || [];\r\n  \r\n  const payout = partnerPayouts.find(p => p.id === payoutId);\r\n  if (!payout) throw new Error('Payout not found');\r\n  \r\n  payout.status = 'completed';\r\n  payout.completedAt = new Date().toISOString();\r\n  payout.reference = reference;\r\n  \r\n  // Mark transactions as paid\r\n  markTransactionsAsPaid(partnerId, payout.transactionIds, payoutId);\r\n  \r\n  payouts[partnerId] = partnerPayouts;\r\n  localStorage.setItem(PAYOUTS_KEY, JSON.stringify(payouts));\r\n  \r\n  return payout;\r\n}\r\n\r\n/**\r\n * Fail payout with reason\r\n */\r\nexport function failPayout(payoutId, partnerId, reason = '') {\r\n  const payouts = JSON.parse(localStorage.getItem(PAYOUTS_KEY) || '{}');\r\n  const partnerPayouts = payouts[partnerId] || [];\r\n  \r\n  const payout = partnerPayouts.find(p => p.id === payoutId);\r\n  if (!payout) throw new Error('Payout not found');\r\n  \r\n  payout.status = 'failed';\r\n  payout.failureReason = reason;\r\n  payout.failedAt = new Date().toISOString();\r\n  \r\n  // Transactions remain as earned, can retry\r\n  \r\n  payouts[partnerId] = partnerPayouts;\r\n  localStorage.setItem(PAYOUTS_KEY, JSON.stringify(payouts));\r\n  \r\n  return payout;\r\n}\r\n\r\n/**\r\n * Get payout summary\r\n */\r\nexport function getPayoutSummary(partnerId) {\r\n  const payouts = getPayoutHistory(partnerId, 100); // All time\r\n  \r\n  const completed = payouts.filter(p => p.status === 'completed');\r\n  const pending = payouts.filter(p => p.status === 'pending');\r\n  const failed = payouts.filter(p => p.status === 'failed');\r\n  \r\n  const totalPaidOut = completed.reduce((sum, p) => sum + p.amount, 0);\r\n  const pendingAmount = pending.reduce((sum, p) => sum + p.amount, 0);\r\n  \r\n  return {\r\n    partnerId,\r\n    totalPaidOut: Math.round(totalPaidOut * 100) / 100,\r\n    pendingPayouts: pending.length,\r\n    pendingAmount: Math.round(pendingAmount * 100) / 100,\r\n    completedPayouts: completed.length,\r\n    failedPayouts: failed.length,\r\n    averagePayoutAmount: completed.length > 0 ?\r\n      Math.round((totalPaidOut / completed.length) * 100) / 100 : 0,\r\n    lastPayoutDate: completed.length > 0 ? completed[0].completedAt : null,\r\n  };\r\n}\r\n\r\n/**\r\n * Get payout statistics (admin view)\r\n */\r\nexport function getPayoutStatistics() {\r\n  const payouts = JSON.parse(localStorage.getItem(PAYOUTS_KEY) || '{}');\r\n  \r\n  let totalPayedOut = 0;\r\n  let totalPending = 0;\r\n  let totalFailed = 0;\r\n  let payoutsCompleted = 0;\r\n  let payoutsPending = 0;\r\n  let payoutsFailed = 0;\r\n  \r\n  for (const partnerPayouts of Object.values(payouts)) {\r\n    for (const p of partnerPayouts) {\r\n      if (p.status === 'completed') {\r\n        totalPayedOut += p.amount;\r\n        payoutsCompleted++;\r\n      } else if (p.status === 'pending') {\r\n        totalPending += p.amount;\r\n        payoutsPending++;\r\n      } else if (p.status === 'failed') {\r\n        totalFailed += p.amount;\r\n        payoutsFailed++;\r\n      }\r\n    }\r\n  }\r\n  \r\n  return {\r\n    totalPaidOut: Math.round(totalPayedOut * 100) / 100,\r\n    totalPending: Math.round(totalPending * 100) / 100,\r\n    totalFailed: Math.round(totalFailed * 100) / 100,\r\n    payoutsCompleted,\r\n    payoutsPending,\r\n    payoutsFailed,\r\n    totalPayouts: payoutsCompleted + payoutsPending + payoutsFailed,\r\n    averagePayoutAmount: (payoutsCompleted > 0) ?\r\n      Math.round((totalPayedOut / payoutsCompleted) * 100) / 100 : 0,\r\n  };\r\n}\r\n\r\n/**\r\n * Generate payout report\r\n */\r\nexport function generatePayoutReport(startDate, endDate) {\r\n  const payouts = JSON.parse(localStorage.getItem(PAYOUTS_KEY) || '{}');\r\n  \r\n  const start = new Date(startDate);\r\n  const end = new Date(endDate);\r\n  \r\n  const filtered = [];\r\n  \r\n  for (const [partnerId, partnerPayouts] of Object.entries(payouts)) {\r\n    for (const payout of partnerPayouts) {\r\n      const payoutDate = new Date(payout.completedAt || payout.requestedAt);\r\n      if (payoutDate >= start && payoutDate <= end) {\r\n        filtered.push({ ...payout, partnerId });\r\n      }\r\n    }\r\n  }\r\n  \r\n  const byStatus = {\r\n    completed: filtered.filter(p => p.status === 'completed'),\r\n    pending: filtered.filter(p => p.status === 'pending'),\r\n    failed: filtered.filter(p => p.status === 'failed'),\r\n  };\r\n  \r\n  const totalAmount = byStatus.completed.reduce((sum, p) => sum + p.amount, 0);\r\n  \r\n  return {\r\n    reportPeriod: { start: startDate, end: endDate },\r\n    totalPayouts: filtered.length,\r\n    totalAmount: Math.round(totalAmount * 100) / 100,\r\n    byStatus: {\r\n      completed: {\r\n        count: byStatus.completed.length,\r\n        amount: Math.round(byStatus.completed.reduce((sum, p) => sum + p.amount, 0) * 100) / 100,\r\n      },\r\n      pending: {\r\n        count: byStatus.pending.length,\r\n        amount: Math.round(byStatus.pending.reduce((sum, p) => sum + p.amount, 0) * 100) / 100,\r\n      },\r\n      failed: {\r\n        count: byStatus.failed.length,\r\n        amount: Math.round(byStatus.failed.reduce((sum, p) => sum + p.amount, 0) * 100) / 100,\r\n      },\r\n    },\r\n    payouts: filtered.sort((a, b) => new Date(b.completedAt || b.requestedAt) - new Date(a.completedAt || a.requestedAt)),\r\n  };\r\n}\r\n\r\n// === Helper Functions ===\r\n\r\nfunction addBusinessDays(date, days) {\r\n  const result = new Date(date);\r\n  let count = 0;\r\n  \r\n  while (count < days) {\r\n    result.setDate(result.getDate() + 1);\r\n    // Skip weekends\r\n    if (result.getDay() !== 0 && result.getDay() !== 6) {\r\n      count++;\r\n    }\r\n  }\r\n  \r\n  return result;\r\n}\r\n\r\nfunction getPayoutStatusDisplay(status) {\r\n  const displays = {\r\n    pending: 'â³ Processing',\r\n    processing: 'ðŸ”„ In Progress',\r\n    completed: 'âœ… Completed',\r\n    failed: 'âŒ Failed',\r\n  };\r\n  return displays[status] || status;\r\n}\r\n"],"names":[],"mappings":"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"}